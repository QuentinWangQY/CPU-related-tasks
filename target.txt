实验要求：
实验一：多路选择器与ALU
1. 设计并实现ALU结构中的多路选择器，接口定义如下：
	module MUX1X2 (		//1位2选1多路选择器
		input X1, X0,
		input S,
		output Y
	);
	module MUX32X2 (		//32位2选1多路选择器
		input [31:0] X1, X0;
		input S;
		output [31:0] Y
	);
	module MUX32X4 (		//32位4选1多路选择器
		input [31:0] X3, X2, X1, X0,
		input [1:0] S,
		output [31:0] Y
	);
	
2. 设计并实现CPU结构中的ALU模块，接口定义如下：
	module ALU (
		input [31:0] A, B,			//32位操作数	
		input [2:0] ALUctr,		//3位ALU控制信号
		output [31:0] Result,	//32位运算结果
		output Overflow,			//溢出标志
		output Z						//Zero-零标志
	);
3. 设计仿真，分析并验证所实现的ALU模块功能（指令集中所有指令都需要验证）。


实验二：单周期CPU
1. 阅读单周期处理器结构中各部件模块代码，理解其接口含义与工作原理；
2. 编写CPU顶层模块，实例化处理器结构中各部件模块，构成完整的单周期处理器结构，接口定义如下：
	module CPU (
		input Clk,				//时钟信号
		output [31:0] PC,		//指令地址
		output [31:0] Inst,	//指令
		output [31:0] R		//指令的ALU运算结果
	);
3. 设计一个指令序列写入指令存储器模块InstROM，要求包含指令集中的所有指令，其中条件跳转beq指令至少含有两条，分别实现跳转成功与跳转失败两种条件。
4. 对所实现的单周期处理器进行仿真验证，结合指令序列与仿真波形分析实验结果。

设计参考：

1. 实现过程中，各模块的实例化写法推荐使用“名称引用”的写法；
2. 处理器结构中的程序计数器PC、寄存器组RegFiles与数据存储器DataRAM在设计时均已加入初始化命令；
3. 处理器结构中的程序计数器PC、寄存器组RegFiles与数据存储器DataRAM中，数据的更新方式统一采用时钟下降沿更新；
4. 指令存储器为按字节寻址，地址从0开始，如指令存储器定义为“[31:0] InstROM [31:0]” ，其第5条指令的外部地址为“32’h00000014”；
5. 单周期处理器结构中所使用的多路选择器，需自行设计实现，接口定义如下：
	module MUX3X2 (		//3位2选1多路选择器
		input [2:0] X1, X0,
		input S,
		output [2:0] Y
	);
	module MUX5X2 (		//5位2选1多路选择器
		input [4:0] X1, X0,
		input S,
		output [4:0] Y
	);

6. 激励文件Verilog Test Fixture可参考如下代码：
        module xxx;		//激励文件；
	…			//仿真模块实例化；
	initial begin		//激励信号设置；
	    // Initialize Inputs
                 Clk = 0;		//时钟信号初始化；
	    Reset = 1;		//程序计数器复位
	    #100；		//等待复位
	    Reset = 0;		//复位结束
	end			//激励信号内容结束；
	always #50 Clk = ~Clk;	//生成周期为100的时钟信号；
        endmodule		//激励文件结束；


实验三：流水线CPU
1. 阅读流水线CPU中各部件模块代码，理解其接口含义与工作逻辑；
2. 参照五级流水线结构，完成IF、ID、EX、MEM、WR流水功能段（分别对应STAGE_IF、STAGE_ID、STAGE_EX、STAGE_MEM、STAGE_WR模块）的设计，向模块中添加功能逻辑部分内容，并进行仿真验证；
3. 设计指令序列对所实现的流水线处理器进行仿真验证，结合指令序列与仿真波形分析实验结果。
注：可沿用单周期处理器设计实验中所设计的指令序列，但基础流水线结构并未考虑流水线中存在的冒险问题，如因指令序列中存在冒险问题而无法得到正确结果，需对指令执行过程进行分析，说明指令不能正常执行的原因。

设计参考：
1. 触发器在Verilog HDL设计中均定义为reg（寄存器）类型的变量，该类型变量初值为不定值x，故需对其赋予初值（或对其进行初始化）才能在仿真过程中正常工作。
2. 程序计数器PC与所有的流水线寄存器均设置有复位信号Reset，高有效，异步清零。
3. 在仿真过程的初始化阶段需先使能复位信号，使程序计数器清零，随后进入正常仿真过程。
4. 激励文件Verilog Test Fixture可参考如下代码：
        module xxx;		//激励文件；
	…			//仿真模块实例化；
	initial begin		//激励信号设置；
	    // Initialize Inputs
                 Clk = 0;		//时钟信号初始化；
	    Reset = 1;		//程序计数器复位
	    #100；		//等待复位
	    Reset = 0;		//复位结束
	end			//激励信号内容结束；
	always #50 Clk = ~Clk;	//生成周期为100的时钟信号；
        endmodule		//激励文件结束；


实验四：数据冒险处理

1. 在实验三流水线处理器结构的基础上，使用数据转发技术解决指令流水线中的普通数据冒险问题，并用指令序列仿真验证；
2. 进一步修改硬件结构，增加load-use数据冒险检测模块，为流水线寄存器添加相关控制信号，以解决指令流水线中的load-use数据冒险问题，并用指令序列仿真验证。

设计参考：
    为实现流水线的阻塞，需要对寄存器（PC、IF_ID）添加写使能控制信号EN，参考如下：
		module PC (
			input Clk,				// Clock signal
			input Clrn, 			// Synchronous clear (active low)
			input EN,				// Enable signal
			input [31:0] PCin,		// PC input
			output reg [31:0] Pcout);		// PC output
			reg [31:0] PC;
		// Synchronous clear and update on the falling clock edge
			always @(negedge Clk) begin
				if (!Clrn) PC <= 32'h00000000;
				else if (EN) PC <= PCin;
				end
			assign PCout = PC;
		endmodule
添加load-use数据冒险检测单元DetUnit_load。

load-use处理逻辑：
    a.程序计数器PC写使能无效，使IF级指令延迟一个时钟周期；
    b. 流水线寄存器IF_ID写使能无效，使ID级指令延迟一个时钟周期；
    c. 流水线寄存器ID_Ex控制信号清零，相当于下一个时钟周期在ID级后插入了一条空指令。
    虽然空指令会流经整个指令流水线，在后续流水段中也进行相应功能的操作，但由于控制信号无效，空指令的执行将不会改变处理器的任何状态。


实验五：控制冒险处理
1. 在实验四解决数据冒险问题的流水线结构基础上，修改硬件结构，解决指令流水线当中的控制冒险问题，并用指令序列仿真验证。

设计参考：
    （1）Mem流水段生成的分支指令判断信号M_PCSrc信号流转至Wr流水段W_PCSrc，利用这两个信号进行流水线阻塞条件的判定。
    （2）流水线寄存器Ex_Mem添加清零信号Clrn，其控制逻辑与load-use数据冒险问题解决过程中，在流水线寄存器ID_Ex中添加的清零信号相同，当清零信号有效时，对流水线寄存器中的控制信号进行清零。
控制冒险处理逻辑：
    a. M_PCSrc信号有效表明当前在Mem流水段的指令是一条分支指令，下一条指令应从分支地址处开始执行，W_PCSrc信号同理；
    b. 由于指令流水线结构中分支地址条件及分支地址回传都是在Mem流水段进行的，此时若分支指令后的下一条指令进行跳转，则需要将分支指令后进入流水线的指令无效化，即在IF、ID、Ex流水段中的指令；
    c. 使用M_PCSrc与W_PCSrc信号控制流水线寄存器的Clrn端口，能够达到在两个时钟周期内无效化位于IF、ID、Ex流水段的三条指令的目的，即消除了控制冒险。



